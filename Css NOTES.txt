//?????? QUESTION ?????? name the different types of selectors
//?????? QUESTION ?????? list the order of specificity
//?????? QUESTION ?????? what is a pseudo-selector
//?????? QUESTION ?????? change the color of a h2 to red when someone hovers
//?????? QUESTION ?????? select a h2 which has the class subtitle
//?????? QUESTION ?????? explain the following
h1 + a {}
textarea ~ button {}
ul > li {}
ul li {}


























there are 3 types of selectors
1. element selector. bottom of specificity scale
    body {

    }

2. class selector
    .navbar {

    }

3. id selector
    #navbar {

    }


specificity is the overriding property of css

the specificity for selectors is:
1. inline styling
2. id
3. class
4. element




PSEUDO-SELECTORS
only visible when something is done on the website

h2:hover {
    color: red;
}


this will change the color of h2 when you hover the element


other notable pseudo-selectors include:
li:first-child
li:last-child
li:nth-child(3)         //every 3rd child will be applied the style
li:only-child
a:link                  //style for an unvisited link
a:visited               //style for a visited link




ADJACENT SELECTORS
h1 + a {}               //this will apply styles to all a tags which come after h1 tags



GENERAL SIBLING SELECTORS
this selects elements which follow one another as long as they share the same parent
textarea ~ button {}



THE CHILD SELECTOR
selects every single child of a parent element. direct children!
ul > li {}


DESCENDANT SELECTORS
assuming a list has another list inside it. not necessary direct child, as long as it propagates to the parent
ul li {}




ATTRIBUTE SELECTOR
this is used to select elements based of their attributes
h2[class=subtitle] {}
img[src^='img/homepage'] {}         //this will style all the images in the home page. the ^ means that the source shouldn't be directly equal but instead it should contain or begin what is specified
img[src$='img/homepage.jpg'] {}         // $ means the source should end with
img[src*='img/public'] {}               // * anywhere











//?????? QUESTION ?????? make a background image fill the whole space
//?????? QUESTION ?????? make a background image not to repeat















//background image properties

background-repeat: no-repeat;       //repeat is default
background-size: cover              //covers the entire space







// opacity/ transparency

rgba
a is the transparency

0 is transparent, 1 is opaque




// gradients

this is a transition between 2 colours
there are 2 types
1. radial - circular
background: radial-gradient(red 20%, blue)

2. linear
background: linear-gradient(to right, red, blue)















//?????? QUESTION ?????? list the different types of units with examples
//?????? QUESTION ?????? explain the difference between 5%, 5vh, 5rem and 5em
//?????? QUESTION ?????? explain the different font families
//?????? QUESTION ?????? select a font from google fonts and post here



















// units

1. absolute - px

2. relative - %, em, vw, vh

an element with a width of 50% covers 50% of the parent elements width

50vw is 50% of the screen size and will change according to the screen size changes


rem and em are relative to the font size defined.
rem is relative to the root font size
em is relative to the parent font size



viewport is the dimensions of your device

vw and vh are relative units which allow you to work with the viewport easily

1 vw or vh is equal to 1% of the total body width or body height




// FONTS

font-size: 1.25em               //this bases the font size on the screen size


there are 3 font families
1. serif - they have small lines at the end of the letters. mostly used in formal/ printed spaces
times new roman, georgia
2. san-serif - dont have the lines e.g most websites, much easier to read
calibri, arial
3. monospace - all characters have same size
courier new


font-family: "Times New Roman", serif;                  // this means if times new roman is available, use it, if not use the general serif


using external fonts

go to google fonts and pick the fonts that you want

copy the link tag that they'll give you and make sure you paste it before your style sheet












//?????? QUESTION ?????? list the structure of the box model and explain what each element does
//?????? QUESTION ?????? list the 4 ways which you can do your padding/ margin


























// THE BOX MODEL

    margin
            border
                    padding
                            content

each element has this invisible box


padding doesn't move the content. it gives more room to the content

border is between the padding and margin. it can be styled using a css property border
border: 1px solid red;


margin moves the content around to make it have space among other external elements


padding internal spacing (spacing between border and content)
margin external spacing (spacing between border and external elements)



padding: 10px;              //it is going to add the same value on all sides
padding-right: 10px;         //specify the side
padding: 40px 30px 0 10px;      //top right bottom left
padding: 80px 40px;             //80 for top and bottom, 40 for left and right















//?????? QUESTION ?????? list the different display types
//?????? QUESTION ?????? what are the different float properties















// FLOAT AND DISPLAY TYPES

elements have 3 display types
1. block  - tags moves elements to their own section
2. inline - continues inline e.g span
3. none - hides an element
4. inline-block - combine both features. does not move the element into a new line but it creates spacing for the element

there's a way to change this though using display


FLOAT PROPERTIES
float: right;
this will move the element to the right and the element below it will move to the left of it
float: inherit;
going to take the float property of the parent element. place it at the parent element and the children elements will all inherit the float property
float: non-value;
this is the default float value if you don't specify anything













//?????? QUESTION ?????? assuming you have a class container, make it use flexbox system
//?????? QUESTION ?????? which flex property is responsible for direction and list its different attributes
//?????? QUESTION ?????? which flex property is used to align items in a flex container horizontally and the one responsible for vertical alignment
//?????? QUESTION ?????? how would you arrange elements using flex
//?????? QUESTION ?????? explain flex basis, growth and shrink
//?????? QUESTION ?????? use the basis, growth and shrink shorthand to align a specific element in a flex container
//?????? QUESTION ?????? align a single item in a flex container




















///             FLEXBOX         ///

it is a display that comes with a range of properties allowing you to arrange items easily


it contains two elements, the container which os the parent element and the items which are the child elements

.container {
display: flex;
//create a flex container

flex-direction: column;
// row, column-reverse, row-reverse

flex-wrap: nowrap;
// when you wrap an item, it is going to move it to a new row instead of squeezing them to one row. no wrap is the default property

justify-content: center;
// horizontal alignment
// flex-start, flex-end, space-between: creates space between the items, space-around: creates space around the items

align-items: center;
//vertical alignment
// flex-start, flex-end, stretch: stretch from top to bottom, baseline: align items along a same line no matter the size,

}



.container-item {

//you can use inline styling using the order property with a number to specify the positioning


flex: 2;
// in the case where you want the columns to have different sizes, we'll use flex with different numbers



flex-basis: 100px
// inline
//define the minimum width of an item, can be any value

flex-grow: 1;
// inline
// default is 0
// every item is going to get an equal amount of the extra space. when we go below the minimum width (default is 100px), the excess proportion is removed

flex-shrink: 1;
//inline
//default value is 1
// similar to flex grow but it defines the shrinkage
// 0 no shrinkage

flex: 1 1 100px;
/ inline
// this is a shortcut to use flex grow, shrink and basis in one go
// it takes in 3 values in the order: grow, shrink or basis

align-self: flex-start
//inline
// align items vertically
// use the same values, flex-start, flex-end and center. stretch and baseline dont work though
// overrides container alignment

}






.container{
    display: grid;
    grid-template-row: 2;
    grid-template-column: 3;
    justify-content: start, end, center, space-evenly, space-around
    align-content:
    column
}
















//?????? QUESTION ?????? assuming you have a class container, make it use a grid system
//?????? QUESTION ?????? make your grid have 3 columns and 2 rows
//?????? QUESTION ?????? what properties are responsible for a grid's horizontal and vertical alignment an list out their different attributes
//?????? QUESTION ?????? which grid properties are responsible for spacing between the grid items







///         GRID            ///


similar to flexbox however this is more manual and gives you more control

you can control the height and width unlike in flexbox where you can only control the width


.grid-container {

display: grid;
//also use a display property for activation

grid-template-columns: 10px 400px 50px;
grid-template-row: auto auto;
// divides your grid based on the rows and columns you specify. auto is more convenient

justify-content: start;
// horizontal alignment
// start, end, center, space-around, space-evenly
// this will ignore our template column property


align-content:
// vertical alignment
// start, end, center, space-around, space-evenly. space-between


grid-column-gap: 150px;
grid-row-gap: 300px;
grid-gap: 20px 50px;
//row and column shortcut

}



.grid-item {

grid-column: 1/3;
grid-row: 1 / span 3;
// lines are basically the rows and columns. using this, we can decide to choose where we want our items to start and end. grid-row 1/3 reads start 1st row and end at the 3rd row
// instead of specifying line end in the case where the grid is big, you can specify the distance that you want it to take up. the key word is span which simply says take up x spaces



grid-area: row start / column start / row end / column end
grid-area 2 / 1 / span 2 / span 3
//there is a way you can do the grid-row and column in one line using grid-area

}











///         TRANSITION PROPERTY             ///


transition: property that you want to transition (you can also select all), duration, style: ease is standard, linear, ease-in-out, delay

used on the selector without the pseudo selector


transition: background 2s ease-in-out 1s;

transition: background, padding 300ms linear

-webkit-     = chrome and safari prefix
-moz-        = mozilla
-o-          = opera
-ms-         = microsoft


-webkit-transition: all 300ms ease
-moz-transition: all 300ms ease







///         TRANSFORM PROPERTY          ///



transform: translate(x-axis, y-axis);
transform: translate(50px, -30px);



transform: scale(2.5);
// this reads scale by 2.5 times



transform: rotate(-90deg);
transform: skew(65deg);



the matrix function is a shorthand method that summarizes all the above transformations


it accepts 6 arguments

transform: matrix( scale x, skew x no units, use decimal for angle, skew y, scale y, translate x, translate y);

transform: matrix(1, 0.45, 0.45, 1, 100, 50 );




///         ANIMATIONS          ///

this is better than transformation as you define the changes then you can choose what you want to apply it to


it is split up into keyframes, start, end and you can add your own keyframes also

you can name it whatever you want


@keyframes red-to-black {
    from {background: red;}
    to {background: black}
}


@keyframes translate_element {
    0% {background: red; transform: translate(0px, 60px;)}
    37 % {background: blue;}
    100% {background: yellow;}
}




in order to apply the animation, select the element you want to apply the animation to


#some-id {
    animation-name: red-to-black;
    animation-duration: 4s;
    animation-timing-function: ease;   //linear, ease etc
    animation-delay: 2s;        // you can also use a negative value
    animation-iteration-count:  infinite;
    animation-direction: normal;       //reverse starts from the end, alternate goes normal then reverse, alternate-reverse
}



you can simplify this by using the animation shorthand


.some-class {
    animation: red-to-black duration timing-function delay iteration-count direction
}










///         BEFORE & AFTER PSEUDO ELEMENTS          ///

uses a double colon

the content attribute is the activator of the pseudo class

before basically means inserting the content before the specified element and after comes after the content of the specified element

p::before {
    content: '';
}

pseudo elements dont work for images


p::after {
    content: 'Hello';           // this will display hello to the page
}



pseudo elements are inline by default


use cases of before and after include


content: url('fjvdp');
inserting background images


content: open-quote;
content: close-quote;










///         CSS POSITIONING         ///


1.  static is the default positioning which means that the element should follow the normal flow of documents

z-index doesn't work in static elements



2.  relative positioning works almost the same way as static positioning but it allows you to do 4 things that static positioning doesn't
with relative positioning you can change the top, right, bottom and left position of the element

.child {
    position: relative;
    left: 10px;             //this will move the element 10px on the left
}


with relative positioning, it will take the element out of the regular flow of elements and it might overflow the other static elements



3. absolute. with absolute, it will act like the element doesn't exist at all and it will kind of not occupy any space at all in the sense that if you delete the element no visible changes show on the page

this is important in the case where you want to stick an element somewhere without moving anything else

one thing to note with absolute is that the element will reference a "hypothetical" parent element and moving the element using top, left, right and bottom will be based off that parent element

in order to get around this, we will change the class of the parent which we want to absolute position the child to position relative.

absolute positioning works with the nearest parent whose class isn't static otherwise it will go back all the way to the root html element

absolute is relative to its original position, however, once you start adding top, left etc. it becomes relative to the nearest parent whose position isn't static



4.  fixed positioning   - similar to absolute positioning. the difference is that fixed position will ignore all other parent elements and it will be based of off the root html element


they also stay in the same place when you scroll



5. sticky       - this is a combination of relative and fixed position. it positions like relative positioning where you won't notice any difference but when you start scrolling it becomes fixed and it stays at the top of the page











///         OBJECT FIT              ///

used to make responsive images.

it has different properties namely

1. contain  -   maintains the aspect ration of the image and it's going to squeeze the image so that it fits in the container
   this however might not fit the container perfectly

2. cover    -   maintains the aspect ratio and it is going to crop out the excess







how to make images have the same sizes

1. add height to your images so that they can have the same size although some images will be stretched
2. in order to remove the stretching, we will use object fit cover which maintains the same aspect ratio of the image and crops of the excess
3. use object position to choose the side of the image you want to be shown and not cropped out

img {
    height: 7rem;
    object-fit: cover;
    object-position: center center;
}






// SELECTORS


*{}                             -   selects everything


.some-class                     - preferred over id and element selectors


div.red                         - div with a particular class


li, span{}                      - li or spans will be selected


ul li {}                        - selects all the li's inside the ul, the space basically means anything inside the element that comes before it i.e any li inside the ul whether it is a direct child or not


ul > li {}                      - selects only direct children


li.red ~ li {}                  - all the siblings which come after an li which has a class of red


li.red + li {}                  - next sibling li which comes an li with a class of red


input:hover {}


input:focus {}


li:first-child {}


li:last-child {}


li:nth-child(3) {}


li:only-child {}                    - it is going to select if it is the only child


li:not(.red)                        - any li that does not have the class of red


[type='password'] {}                - will select the element which has the attribute of type = password


[src ^='12'] {}                       - begins with 12


[src $='12'] {}                       - ends with 12


[src *='12'] {}                       - contains 12 anywhere













































