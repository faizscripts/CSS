there are 3 types of selectors
1. element selector. bottom of specificity scale
    body {

    }

2. class selector
    .navbar {

    }

3. id selector
    #navbar {

    }


specificity is the overriding property of css

the specificity for selectors is:
1. inline styling
2. id
3. class
4. element




PSEUDOSELECTORS
only visible when something is done on the website

h2:hover {
    color: red;
}


this will change the color of h2 when you hover the element


other notable psudoselectors include:
li:first-child
li:last-child
li:nth-child(3)         //every 3rd child will be applied the style
li:only-child
a:link                  //style for an unvisited link
a:visited               //style for a visited link




ADJACENT SELECTORS
h1 + a {}               //this will apply styles to all a tags which come after h1 tags



GENERAL SIBLING SELECTORS
this selects elements which follow one another as long as they share the same parent
textarea ~ button {}



THE CHILD SELECTOR
selects every single child of a parent element. direct children!
ul > li {}


DESCENDANT SELECTORS
assuming a list has another list inside it. not necessary direct child, as long as it propagates to the parent
ul li {}




ATTRIBUTE SELECTOR
this is used to select elements based of their attributes
h2[class=subtitle] {}
img[src^='img/homepage'] {}         //this will style all the images in the home page. the ^ means that the source shouldn't be directly equal but instead it should contain or begin what is specified
img[src$='img/homepage.jpg'] {}         // $ means the source should end with
img[src*='img/public'] {}               // * anywhere




//background image properties

background-repeat: no-repeat;       //repeat is default
background-size: cover              //covers the entire space







// opacity/ transparency

rgba
a is the transparency

0 is transparent, 1 is opaque




// gradients

this is a transition between 2 colours
there are 2 types
1. radial - circular
background: radial-gradient(red 20%, blue)

2. linear
background: linear-gradient(to right, red, blue);




// units

1. absolute - px

2. relative - %, em, vw, vh

an element with a width of 50% covers 50% of the parent elements width

50vw is 50% of the screen size and will change according to the screen size changes


rem and em are relative to the font size defined.
rem is relative to the root font size
em is relative to the parent font size



viewport is the dimensions of your device

vw and vh are relative units which allow you to work with the viewport easily

1 vw or vh is equal to 1% of the total body width or body height




// FONTS

font-size: 1.25em               //this bases the font size on the screen size


there are 3 font families
1. serif - they have small lines at the end of the letters. mostly used in formal/ printed spaces
times new roman, georgia
2. san-serif - dont have the lines e.g most websites, much easier to read
calibri, arial
3. monospace - all characters have same size
courier new


font-family: "Times New Roman", serif;                  // this means if times new roman is available, use it, if not use the general serif


using external fonts

go to google fonts and pick the fonts that you want

copy the link tag that they'll give you and make sure you paste it before your style sheet





// THE BOX MODEL

    margin
            border
                    padding
                            content

each element has this invisible box


padding doesn't move the content. it gives more room to the content

border is between the padding and margin. it can be styled using a css property border
border: 1px solid red;


margin moves the content around to make it have space among other external elements


padding internal spacing (spacing between border and content)
margin external spacing (spacing between border and external elements)



padding: 10px;              //it is going to add the same value on all sides
padding-right: 10px;         //specify the side
padding: 40px 30px 0 10px;      //top right bottom left
padding: 80px 40px;             //80 for top and bottom, 40 for left and right








// FLOAT AND DISPLAY TYPES

elements have 3 display types
1. block  - tags moves elements to their own section
2. inline - continues inline e.g span
3. none - hides an element
4. inline-block - combine both features. does not move the element into a new line but it creates spacing for the element

there's a way to change this though using display


FLOAT PROPERTIES
float: right;
this will move the element to the right and the element below it will move to the left of it
float: inherit;
float: non-value;









///             FLEXBOX         ///

it is a display that comes with a range of properties allowing you to arrange items easily


it contains two elements, the container which os the parent element and the items which are the child elements

.container {
display: flex;
//create a flex container

flex-direction: column;
// row, column-reverse, row-reverse

flex-wrap: nowrap;
// when you wrap an item, it is going to move it to a new row instead of squeezing them to one row. no wrap is the default property

justify-content: center;
// horizontal alignment
// flex-start, flex-end, space-between: creates space between the items, space-around: creates space around the items

align-items: center;
//vertical alignment
// flex-start, flex-end, stretch: stretch from top to bottom, baseline: align items along a same line no matter the size,

}



.container-item {

//you can use inline styling using the order property with a number to specify the positioning


flex: 2;
// in the case where you want the columns to have different sizes, we'll use flex with different numbers



flex-basis: 100px
// inline
//define the minimum width of an item, can be any value

flex-grow: 1;
// inline
// default is 0
// every item is going to get an equal amount of the extra space. when we go below the minimum width (default is 100px), the excess proportion is removed

flex-shrink: 1;
//inline
// similar to flex grow but it defines the shrinkage
// 0 no shrinkage

flex: 1 1 100px;
/ inline
// this is a shortcut to use flex grow, shrink and basis in one go
// it takes in 3 values in the order, grow, shrink or basis

align-self: flex-start
//inline
// align items vertically
// use the same values, flex-start, flex-end and center. stretch and baseline dont work though
// overrides container alignment

}









///         GRID            ///


similar to flexbox however this is more manual and gives you more control

you can control the height and width unlike in flexbox where you can only control the width


.grid-container {

display: grid;
//also use a display property for activation

grid-template-columns: 10px 400px 50px;
grid-template-row: auto auto;
// divides your grid based on the rows and columns you specify. auto is more convenient

justify-content: start;
// horizontal alignment
// start, end, center, space-around, space-evenly
// this will ignore our template column property


align-content:
// vertical alignment
// start, end, center, space-around, space-evenly. space-between


grid-column-gap: 150px;
grid-row-gap: 300px;
grid-gap: 20px 50px;
//row and column shortcut

}



.grid-item {

grid-column: 1/3;
grid-row: 1 / span 3;
// lines are basically the rows and columns. using this, we can decide to choose where we want our items to start and end. grid-row 1/3 reads start 1st row and end at the 3rd row
// instead of specifying line end in the case where the grid is big, you can specify the distance that you want it to take up. the key word is span which simply says take up x spaces



grid-area: row start / column start / row end / column end
grid-area 2 / 1 / span 2 / span 3
//there is a way you can do the grid-row and column in one line using grid-area

}











///         TRANSITION PROPERTY             ///


transition: property that you want to transition (you can also select all), duration, style: ease is standard, linear, ease-in-out, delay

used on the selector without the pseudo selector


transition: background 2s ease-in-out 1s;

transition: background, padding 300ms linear

-webkit-     = chrome and safari prefix
-moz-        = mozilla
-o-          = opera
-ms-         = microsoft


-webkit-transition: all 300ms ease
-moz-transition: all 300ms ease







///         TRANSFORM PROPERTY          ///



transform: translate(x-axis, y-axis);
transform: translate(50px, -30px);



transform: scale(2.5);
// this reads scale by 2.5 times



transform: rotate(-90deg);
transform: skew(65deg);



the matrix function is a shorthand method that summarizes all the above transformations


it accepts 6 arguments

transform: matrix( scale x, skew x no units, use decimal for angle, skew y, scale y, translate x, translate y);

transform: matrix(1, 0.45, 0.45, 1, 100, 50 );




///         ANIMATIONS          ///

this is better than transformation as you define the changes then you can choose what you want to apply it to


it is split up into keyframes, start, end and you can add your own keyframes also

you can name it whatever you want


@keyframes translate_element {
    from {background: red;}
    to {background: black}
}


@keyframes translate_element {
    0% {background: red; transform: translate(0px, 60px;)}
    37 % {background: blue;}
    100% {background: yellow;}
}




in order to apply the animation, select the element you want to apply the animation to


#some-id {
    animation-name: red-to-black;
    animation-duration: 4s;
    animation-timing-function: ease;   //linear, ease etc
    animation-delay: 2s;        // you can also use a negative value
    animation-iteration-count:  infinite;
    animation-direction: normal;       //reverse starts from the end, alternate goes normal then reverse, alternate-reverse
}



you can simplify this by using the animation shorthand


.some-class {
    animation: red-to-black duration timing-function delay iteration-count direction
}









































